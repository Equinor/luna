#!/usr/bin/env python

# Copyright (C) 2018  Statoil ASA, Norway.
#
# Moclipse is part of Ert, Ensemble Reservoir Tools.
#
# Ert is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# Moclipse is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.
#
# See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
# for more details.

from __future__ import (division, print_function)

import os.path
from collections import namedtuple
from datetime import datetime as dt

import sunbeam
from ecl.summary import EclSumVarType, EclSum

SUNBEAM_ERRORS = ('PARSE_UNKNOWN_KEYWORD', 'PARSE_RANDOM_TEXT',
                  'PARSE_RANDOM_SLASH', 'PARSE_MISSING_DIMS_KEYWORD',
                  'PARSE_EXTRA_DATA', 'PARSE_MISSING_INCLUDE',
                  'UNSUPPORTED_SCHEDULE_GEO_MODIFIER',
                  'UNSUPPORTED_COMPORD_TYPE', 'UNSUPPORTED_INITIAL_THPRES',
                  'UNSUPPORTED_TERMINATE_IF_BHP',
                  'INTERNAL_ERROR_UNINITIALIZED_THPRES',
                  'SUMMARY_UNKNOWN_WELL', 'SUMMARY_UNKNOWN_GROUP')
SUNBEAM_ACTION = sunbeam.action.warn

KEYS = ('FOPR',
        'FGPR',
        'FWPR',
        'FLPR',
        'FVPR',
        'FGSR',
        'FOPP',
        'FWPP',
        'FGPP',
        'FVIR',
        'FWIR',
        'FGIR',
        'FVPT',
        'FOPT',
        'FWPT',
        'FGPT',
        'FWIT',
        'FGIT',
        'FWIP',
        'FOIP',
        'FGIP',
        'FWCT',
        'FGOR',
        'FGLR',
        'FWGR',
        'FPR',
)  # TODO read from SCHEDULE

moclipsestate = namedtuple('moclipsestate',
                           'eclbase schedule grid')

def log(state, msg):
    out = '{}\t{}\n'.format(dt.now(), msg)
    with open(state.eclbase + '.PRT', 'a') as logf:
        logf.write(out)
    return out

# TODO
#
# Perhaps we only need F[OGW]P[RT] and should _fix_ the output to those
#
# Need to get wells, their type (injection/production) as well as report dates.


def _mock(state, step_idx, key):
    """Takes a schedule and a step_idx and returns FOPR/FOPT for that step"""
    now = state.schedule.timesteps[step_idx]
    try:
        nxt = state.schedule.timesteps[step_idx + 1]
    except IndexError:
        nxt = state. schedule.end
    days = (nxt - now).days
    wls = [w for w in state.schedule.wells if w.status(step_idx) == u'OPEN']
    pros = [w for w in wls if w.isproducer(step_idx)]
    injs = [w for w in wls if w.isinjector(step_idx)]

    mockedval = len(pros)**2 * len(injs) * days  # yup

    log(state, 'idx {} pros {} injs {} -> {}'.format(step_idx,
                                                     pros,
                                                     injs,
                                                     mockedval))

    return mockedval


def _extract_var_list(keys, smry):
    var_list = []
    for key in keys:
        wgname = None
        num = -1
        var_type = EclSum.var_type(key)
        if var_type in (EclSumVarType.ECL_SMSPEC_WELL_VAR,
                        EclSumVarType.ECL_SMSPEC_GROUP_VAR):
            try:
                tmp = key.split(':')
                kw = tmp[0]
                wgname = tmp[1]
            except IndexError as err:
                raise ValueError('Broken key {}: {}'.format(key, err))
        elif var_type == EclSumVarType.ECL_SMSPEC_FIELD_VAR:
            kw = key
        else:
            raise ValueError(
                'Only field, well and group variables are allowed, not {}'.format(key))
        var_list.append(smry.addVariable(kw, wgname=wgname, num=num))
    return var_list


def generate_summary(state):
    sim_start = state.schedule.start
    x, y, z = state.grid.getNX(), state.grid.getNY(), state.grid.getNZ()

    ecl_sum = EclSum.restart_writer(state.eclbase, None, -1, sim_start, x, y, z)

    var_list = _extract_var_list(KEYS, ecl_sum)

    msg = 'start={}\nend={}\ntimesteps={}'.format(state.schedule.start,
                                                  state.schedule.end,
                                                  state.schedule.timesteps)
    log(state, msg)

    days = 0
    prev = None
    for idx, step in enumerate(state.schedule.timesteps):
        if prev is not None:
            days = (step - prev).days
        prev = step
        t_step = ecl_sum.add_t_step(idx, sim_days=days)

        for var in var_list:
            key = var.getKey1()
            t_step[key] = _mock(state, idx, key)

        log(state, t_step)

    return ecl_sum


def main(eclbase):
    es = sunbeam.parse(eclbase + '.DATA',
                       [(err, SUNBEAM_ACTION) for err in SUNBEAM_ERRORS])
    sch = es.schedule
    grid = es.state.grid()

    state = moclipsestate(eclbase=eclbase,
                          schedule=sch,
                          grid=grid)

    smry = generate_summary(state)
    smry.fwrite()
    print('Simulation complete.  Wrote {}.'.format(', '.join(smry.keys())))


if __name__ == '__main__':
    from sys import argv
    if len(argv) != 2:
        exit('Usage: moclipse ECL')

    eclbase = argv[1]
    if not os.path.exists(eclbase + '.DATA'):
        exit('No such file {} (.DATA)'.format(eclbase))

    main(eclbase=eclbase, )
